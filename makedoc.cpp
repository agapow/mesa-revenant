// MakeDoc// Written by Paul O. Lewis, June 1998// Last major revision February 1999//// See comments at the bottom of this file// for examples of how to document C++ code// for use with this program//#include <string>#include <vector>using namespace std;typedef vector<string> LabelList;#include <iostream.h>#include <fstream.h>#include <string.h>#include <assert.h>#include <stdio.h>#include <stdlib.h>#include <time.h>#include <ctype.h>#define SHORT_STRING_LENGTH   80#define LONG_STRING_LENGTH   255#define MAX_CLASS_COMPONENTS 200//// A simple String class//class String{   char* str;   private:      void CopyFrom( const char* s );      void AppendString( const char* s );      void AppendChar( const char ch );   public:      String() : str(NULL) {}      String( char* s ) : str(NULL) { CopyFrom(s); }      ~String() { if( str != NULL) delete [] str; }      char* c_str() { return str; }      int length() { return ( str == NULL ? 0 : strlen(str) ); }      String& operator=( char* s )         { CopyFrom(s); return *this; }      String& operator=( String& s )         { CopyFrom( s.str ); return *this; }		String& operator +=( String& s )         { AppendString( s.c_str() ); return *this; }		String& operator +=( const char* s )         { AppendString(s); return *this; }		String& operator +=( const char ch )         { AppendChar(ch); return *this; }		int operator ==( const String& s ) const         { return ( strcmp( str, s.str ) == 0 ? 1 : 0 ); }		friend ostream& operator <<( ostream& os, String& s );};void String::CopyFrom( const char* s ){   if( s == NULL )      return;   if( str != NULL )      delete [] str;    str = new char[ strlen(s) + 1 ];    strcpy( str, s );}void String::AppendString( const char* s ){   if( s == NULL )      return;   if( str == NULL ) {      str = new char[ strlen(s) + 1 ];      strcpy( str, s );      return;   }   int str_length = strlen(str);   int s_length = strlen(s);   char* tmp = new char[ str_length + 1 ];   strcpy( tmp, str );   delete [] str;   str = new char[ str_length + s_length + 1 ];   strcpy( str, tmp );   strcat( str, s );   delete [] tmp;}void String::AppendChar( const char ch ){   if( str == NULL ) {      str = new char[2];      str[0] = ch;      str[1] = '\0';      return;   }   int len = strlen(str);   char* tmp = new char[ len + 1 ];   strcpy( tmp, str );   delete [] str;   str = new char[ len + 2 ];   strcpy( str, tmp );   str[len] = ch;   str[len+1] = '\0';   delete [] tmp;}ostream& operator <<( ostream& os, String& s ){   os << s.str;   return os;}// Parameters are saved in the form of two associations, one// between the parameter name and the parameter type, and the// other between the parameter name and the parameter description.// While this would be easier to do using a specialized container// that stores all three items - name, type, and description - that// would involve introducing a new class not used in the rest of// the NCL, which I am trying to avoid.struct ClassComponent{	// type	enum {		CLASS,		METHOD,		CONST_METHOD,		ENUMERATION,		MANIP,		OPERATOR,		CAST_OPERATOR,		CONST_OPERATOR,		CONSTRUCTOR,		DESTRUCTOR,		VARIABLE,      TERMINATOR	};	// visibility	enum {		PUBLIC,		PRIVATE,		PROTECTED	};	enum {		FULL_ENTRY = 0,		INDEX_ENTRY = 1	};	int type;	int visibility;	String name;	String returnType;	LabelList paramNames;	LabelList paramTypes;	LabelList paramDescriptions;	LabelList description;	LabelList throws;	ClassComponent() : type(CLASS), visibility(PUBLIC) {}	~ClassComponent() {}	int operator==( const ClassComponent& other ) const		{ return ( name == other.name ? 1 : 0 ); }	void SetName( char* s ) { name = s; }	void SetReturnType( char* s ) { returnType = s; }	void SetVisibility( char* s );	int IsMethod() { return ( ( type==METHOD || type==CONST_METHOD ) ? 1 : 0 ); }	int IsConstMethod() { return ( type==CONST_METHOD ? 1 : 0 ); }	int IsEnumeration() { return ( type==ENUMERATION ? 1 : 0 ); }	int IsManipulator() { return ( type==MANIP ? 1 : 0 ); }	int IsOperator() { return ( ( type==OPERATOR || type==CAST_OPERATOR || type==CONST_OPERATOR ) ? 1 : 0 ); }	int IsCastOperator() { return ( type==CAST_OPERATOR ? 1 : 0 ); }	int IsConstOperator() { return ( type==CONST_OPERATOR ? 1 : 0 ); }	int IsVariable() { return ( type==VARIABLE ? 1 : 0 ); }	int IsClass() { return ( type==CLASS ? 1 : 0 ); }	int IsConstructor() { return ( type==CONSTRUCTOR ? 1 : 0 ); }	int IsDestructor() { return ( type==DESTRUCTOR ? 1 : 0 ); }	int IsTerminator() { return ( type==TERMINATOR ? 1 : 0 ); }	char* GetName()	{ return name.c_str(); }	char* GetReturnType();	char* GetVisibility();	void GetNameExtra( ofstream& outf );	void GetVisibilityAndReturnType( ofstream& outf );	void GetDescription( ofstream& outf, int indexEntry );	void GetParameterList( ofstream& outf );	void GetEnumItemList( ofstream& outf );};char* ClassComponent::GetReturnType(){   if( returnType.length() == 0 )      return "void";	return returnType.c_str();}void ClassComponent::GetNameExtra( ofstream& outf ){	if( IsMethod() || IsConstructor() || IsOperator() )		GetParameterList(outf);	else if( IsEnumeration() )		GetEnumItemList(outf);}void ClassComponent::GetVisibilityAndReturnType( ofstream& outf ){	if( IsCastOperator() )    	outf << " ";	else if( IsMethod() || IsVariable() || IsOperator() ) {		outf << GetVisibility();		outf << GetReturnType();		outf << " ";	}}void ClassComponent::GetDescription( ofstream& outf, int indexEntry ){	int m = description.size();	outf << "<dl>" << endl;	// output lines of the description as a definition	// so it will be indented	outf << "<dd>";	for( int j = 0; j < m; j++ )	{		outf << description[j];		outf << " " << endl;	}	// if a parameter list is appropriate, make it also a	// definition so it will also be indented	int numParams = paramDescriptions.size();	if( !indexEntry && ( IsMethod() || IsConstructor() || IsOperator() ) && ( numParams > 0 ) )	{		outf << "<p>" << endl;		outf << "<dd><dl>" << endl;		outf << "<dt><b>Parameters:</b>";		for( int k = 0; k < numParams; k++ )		{			outf << "<dd>" << paramNames[k];			outf << " - " << paramDescriptions[k];			outf << endl;		}		outf << "</dl></dd>" << endl;	}	else if( !indexEntry && ( IsEnumeration() ) && ( numParams > 0 ) )	{		outf << "<p>" << endl;		outf << "<dd><dl>" << endl;		outf << "<dt><b>Enum items:</b>";		for( int k = 0; k < numParams; k++ )		{			outf << "<dd>" << paramNames[k] << " ";			if( paramTypes[k].size() > 0 )				outf << " ( = " << paramTypes[k] << ") ";			outf << paramDescriptions[k];			outf << endl;		}		outf << "</dl></dd>" << endl;	}	outf << "</dl>" << endl;}void ClassComponent::GetParameterList( ofstream& outf ){	if( type == CAST_OPERATOR )    	return;	int numParams = paramNames.size();	if( numParams == 0 )		outf << "()";	else {		outf << "( ";		for( int k = 0; k < numParams; k++ ) {			if( k > 0 ) outf << ", ";			outf << paramTypes[k] << " " << paramNames[k];		}		outf << " )";	}    if( type == CONST_OPERATOR )        outf << " const";}void ClassComponent::GetEnumItemList( ofstream& outf ){	int numParams = paramNames.size();	if( numParams == 0 )		outf << " {}";	else {		outf << " { ";		for( int k = 0; k < numParams; k++ ) {			if( k > 0 ) outf << ", ";			outf << paramNames[k];		}		outf << " }";	}}void ClassComponent::SetVisibility( char* s ){	if(!s)		visibility = PUBLIC;	else if( strcmp( s, "public" ) == 0 )		visibility = PUBLIC;	else if( strcmp( s, "private" ) == 0 )		visibility = PRIVATE;	else if( strcmp( s, "protected" ) == 0 )		visibility = PROTECTED;}char* ClassComponent::GetVisibility(){	if( visibility == PRIVATE )		return "private ";	else if( visibility == PROTECTED )		return "protected ";	else		return " ";}class MakeDoc{	int indexOfMaster;	long lineNumber;   int atEOF;	ifstream inf;	ofstream outf;	char pathname[256];	String className;	String within;	String classCopyright;	String outfname;	LabelList classAncestors;	LabelList classAuthors;	LabelList classFiles;	LabelList seeList;	ClassComponent* currComponent;	ClassComponent* componentList;   int whichComponent;   int nextComponent;   void SavePath( char* s );public:	MakeDoc()   {      whichComponent = 0;      nextComponent = 1;      atEOF = 0;      componentList = NULL;      lineNumber = 0L;      currComponent = NULL;   }	~MakeDoc()   {		if( componentList != NULL )         delete [] componentList;	}	bool FileExists( char* fn );   int AtEndOfFile() { return ( atEOF ? 1 : 0 ); }	void Init();	void Abort( char* msg1, char* msg2 = 0 );	void Abort( char* msg1, long i );	void GetLine( ifstream& inf, char* line, int len );	int OnlyWhitespace( char* p );	void SaveDescriptionLine( char* p );	void GetNextWord( char* word, int len, char*& s );	void GetBracketedPhrase( char* word, int len, char*& s );	void GetComponentInfo( ClassComponent* c, char* word );	void ParseTag( char* p );	int FindComment( ifstream& inf );	void WriteComponents();	void DebugListComponents();	void Run( int argc, char* argv[] );};void MakeDoc::Abort( char* msg1, char* msg2 /* = 0 */ ){	assert( msg1 );	cerr << "Error: " << msg1 << endl;	if( msg2 ) cerr << msg2 << endl;	cerr << "Program aborted." << endl << endl;   cerr << "Press ENTER to quit";   while( cin.get() != '\n' ) {}   cerr << endl << endl;	exit(1);}void MakeDoc::Abort( char* msg1, long i ){	char errMsg[LONG_STRING_LENGTH+1];	assert( msg1 );	sprintf( errMsg, msg1, i );	cerr << "Error: " << errMsg << endl;	cerr << "Program aborted." << endl << endl;   cerr << "Press ENTER to quit";   while( cin.get() != '\n' ) {}   cerr << endl << endl;	exit(1);}void MakeDoc::Init(){   componentList = new ClassComponent[MAX_CLASS_COMPONENTS];   whichComponent = 0;   nextComponent = 1;	currComponent = &componentList[0];}void MakeDoc::GetLine( ifstream& inf, char* line, int len ){   // set first three characters of line buffer to '\0'	assert( len > 3 );	line[0] = line[1] = line[2] = line[3] = '\0';	line[len-1] = '\0';   // get a line of text from the file, watching for the EOF character	int ch;   int p = 0;   for(;;)   {      ch = inf.get();      if( ch == EOF ) {         atEOF = 1;         break;      }      else if( ch == 13 || ch == 10 )      {         if( ch == 13 && (int)inf.peek() == 10 )            inf.get();         break;      }      else if( p==len-1 ) {         char tmp[81];         sprintf( tmp, "file line %d too long.", ++lineNumber );         Abort(tmp);      }      else {         line[p++] = (char)ch;      }   }   line[p] = '\0';	lineNumber++;}int MakeDoc::OnlyWhitespace( char* p ){	if( *p == '\0' )		return 1;	int darkSpaceFound = 0;	for( char* pp = p; *pp; pp++ ) {		if( isspace(*pp) ) continue;		darkSpaceFound = 1;		break;	}	return !darkSpaceFound;}void MakeDoc::SaveDescriptionLine( char* p ){	currComponent->description.push_back(p);}void MakeDoc::GetNextWord( char* word, int len, char*& s ){	word[len-1] = '\0';	assert( len > 0 );	if( !s || strlen(s) == 0 ) {		word[0] = '\0';		return;	}	// skip leading whitespace	while( *s && isspace(*s) ) s++;	// read up to len characters from s and store in word	for( int i = 0; i < len; i++ ) {		word[i] = *s++;		if( word[i] == '\0' ) {			s--;			break;		}		if( isspace( word[i] ) ) {			word[i] = '\0';			break;		}	}}void MakeDoc::GetBracketedPhrase( char* word, int len, char*& s ){	word[len-1] = '\0';	assert( len > 0 );	if( !s || strlen(s) == 0 ) {		word[0] = '\0';		return;	}	// skip leading whitespace	while( *s && isspace(*s) ) s++;	// check to make sure a bracketed phrase exists	if( *s == '\0' )		return;	// next character should be '['	if( *s == '[' )		s++;	else		Abort( "expecting '[' on line %d.", lineNumber );	// read up to len characters from s and store in word	for( int i = 0; i < len; i++ ) {		word[i] = *s++;		if( word[i] == '\0' )			Abort( "expecting ']' in line %d.", lineNumber );		if( word[i] == ']' ) {			word[i] = '\0';			break;		}		if( word[i] == '<' ) {			// replace with HTML special character code otherwise			// this will be interpreted as an HTML tag in a browser			word[i++] = '&';			word[i++] = '#';			word[i++] = '6';			word[i]   = '0';		}	}}void MakeDoc::GetComponentInfo( ClassComponent* c, char* word ){	// word could look like any of the following:	//   [void]	//   [int]                     --> assume public	//   [int:protected]	//   [ostream&:protected]	//   [const NxsGDADataBlock&]  --> assume public	//   [NxsArrayAsVector<int>:private]	//   [void:private]	char* p = word;	if( !p || *p == '\0' ) {		// did not find '[', assume [void:public]		c->SetReturnType( "void" );		c->SetVisibility( "public" );	}	// p now points to string representing return type	char* pp = strchr( word, ':' );	if(pp) {		*pp = '\0';		pp++;	}	// pp is now either NULL or it points to "public", "private",	// or "protected"	c->SetReturnType(p);	c->SetVisibility(pp);}void MakeDoc::ParseTag( char* p ){	char word[SHORT_STRING_LENGTH+1];	assert(p);	char* pp = p;	if( *pp != '@' )		Abort( "Expecting tag character ('@') in line %d.", lineNumber );	pp++;	GetNextWord( word, SHORT_STRING_LENGTH, pp );	if( strcmp( word, "class" ) == 0 ) {		currComponent->type = ClassComponent::CLASS;      indexOfMaster = whichComponent;		// get name of component		GetNextWord( word, SHORT_STRING_LENGTH, pp );      className = word;		currComponent->name = word;	}	else if( strcmp( word, "terminator" ) == 0 ) {		currComponent->type = ClassComponent::TERMINATOR;	}	else if( strcmp( word, "ancestor" ) == 0 ) {		GetNextWord( word, SHORT_STRING_LENGTH, pp );		classAncestors.push_back(word);	}	else if( strcmp( word, "see" ) == 0 ) {		GetNextWord( word, SHORT_STRING_LENGTH, pp );		seeList.push_back(word);	}	else if( strcmp( word, "author" ) == 0 ) {		GetNextWord( word, SHORT_STRING_LENGTH, pp );		String s = word;		s += " ";		s += pp;		classAuthors.push_back( s.c_str() );	}	else if( strcmp( word, "file" ) == 0 ) {		GetNextWord( word, SHORT_STRING_LENGTH, pp );		classFiles.push_back(word);	}	else if( strcmp( word, "within" ) == 0 ) {		GetNextWord( word, SHORT_STRING_LENGTH, pp );		within = word;	}	else if( strcmp( word, "copyright" ) == 0 ) {		GetNextWord( word, SHORT_STRING_LENGTH, pp );		classCopyright = word;		classCopyright += " ";		classCopyright += pp;	}	else if( strcmp( word, "constructor" ) == 0 ) {		currComponent->type = ClassComponent::CONSTRUCTOR;		// get name of component		GetNextWord( word, SHORT_STRING_LENGTH, pp );		currComponent->name = className;	}	else if( strcmp( word, "destructor" ) == 0 ) {		currComponent->type = ClassComponent::DESTRUCTOR;		// get name of component		GetNextWord( word, SHORT_STRING_LENGTH, pp );		currComponent->name = "~";		currComponent->name += className;		currComponent->name += "()";	}	else if( strcmp( word, "method" ) == 0 ) {		currComponent->type = ClassComponent::METHOD;		// get name of component		GetNextWord( word, SHORT_STRING_LENGTH, pp );		currComponent->name = word;		// get return type		GetBracketedPhrase( word, SHORT_STRING_LENGTH, pp );		GetComponentInfo( currComponent, word );	}	else if( strcmp( word, "constmethod" ) == 0 ) {		currComponent->type = ClassComponent::CONST_METHOD;		// get name of component		GetNextWord( word, SHORT_STRING_LENGTH, pp );		currComponent->name = word;		// get return type		GetBracketedPhrase( word, SHORT_STRING_LENGTH, pp );		GetComponentInfo( currComponent, word );	}	else if( strcmp( word, "enumeration" ) == 0 ) {		currComponent->type = ClassComponent::ENUMERATION;		// get name of component (usually there will be no name)		GetNextWord( word, SHORT_STRING_LENGTH, pp );		currComponent->name = word;	}	else if( strcmp( word, "operator" ) == 0 ) {		currComponent->type = ClassComponent::OPERATOR;		// get name of component		GetNextWord( word, SHORT_STRING_LENGTH, pp );		currComponent->name = word;		// get return type		GetBracketedPhrase( word, SHORT_STRING_LENGTH, pp );		GetComponentInfo( currComponent, word );	}	else if( strcmp( word, "constoperator" ) == 0 ) {		currComponent->type = ClassComponent::CONST_OPERATOR;		// get name of component		GetNextWord( word, SHORT_STRING_LENGTH, pp );		currComponent->name = word;		// get return type		GetBracketedPhrase( word, SHORT_STRING_LENGTH, pp );		GetComponentInfo( currComponent, word );	}	else if( strcmp( word, "castoperator" ) == 0 ) {		currComponent->type = ClassComponent::CAST_OPERATOR;		// get name of component		GetNextWord( word, SHORT_STRING_LENGTH, pp );		currComponent->name = word;		// get return type		GetBracketedPhrase( word, SHORT_STRING_LENGTH, pp );		GetComponentInfo( currComponent, word );	}	else if( strcmp( word, "manipulator" ) == 0 ) {		currComponent->type = ClassComponent::MANIP;		// get name of component		GetNextWord( word, SHORT_STRING_LENGTH, pp );		currComponent->name = word;	}	else if( strcmp( word, "throws" ) == 0 ) {		// get name of exception		GetNextWord( word, SHORT_STRING_LENGTH, pp );		currComponent->throws.push_back(word);	}	else if( strcmp( word, "variable" ) == 0 ) {		// create a separate component for each variable      ClassComponent* cc = &componentList[nextComponent];      nextComponent++;      if( nextComponent == MAX_CLASS_COMPONENTS-1 )         Abort( "Increase MAX_CLASS_COMPONENTS in makedoc.cpp and recompile" );		cc->type = ClassComponent::VARIABLE;		// get name of component		GetNextWord( word, SHORT_STRING_LENGTH, pp );		cc->name = word;		// get return type		GetBracketedPhrase( word, SHORT_STRING_LENGTH, pp );		GetComponentInfo( cc, word );		// save description		GetNextWord( word, SHORT_STRING_LENGTH, pp );		String s = word;		s += " ";		s += pp;		cc->description.push_back( s.c_str() );	}	else if( strcmp( word, "param" ) == 0 ) {		// get name of parameter		GetNextWord( word, SHORT_STRING_LENGTH, pp );		currComponent->paramNames.push_back(word);		// get parameter type		GetBracketedPhrase( word, SHORT_STRING_LENGTH, pp );		currComponent->paramTypes.push_back(word);		// get description		GetNextWord( word, SHORT_STRING_LENGTH, pp );      String s = word;      s += " ";      s += pp;      currComponent->paramDescriptions.push_back( s.c_str() );	}	else if( strcmp( word, "enumitem" ) == 0 ) {		// enumitems are stored as if they were parameters of a method		// get name of enum item		GetNextWord( word, SHORT_STRING_LENGTH, pp );		currComponent->paramNames.push_back(word);		// get enum item value		GetBracketedPhrase( word, SHORT_STRING_LENGTH, pp );		currComponent->paramTypes.push_back(word);		// get description		GetNextWord( word, SHORT_STRING_LENGTH, pp );		String s = word;		s += " ";		s += pp;		currComponent->paramDescriptions.push_back( s.c_str() );	}}// returns true unless end of file reached (in which case atEOF variable// set to true) or a terminator comment foundint MakeDoc::FindComment( ifstream& inf ){	char line[256];	int commentStarted = 0;	int inDescription = 0;	for(;;) {		GetLine( inf, line, 256 );      if( atEOF ) return 0;		// first three characters on line determine whether we are:		// 1) outside of a comment; 2) on first line of a comment;		// 3) inside a comment; or 4) on last line of a comment		char first = line[0];		char second = line[1];		char third = line[2];		char* p = &line[3];		// comments begin with a line starting "/**"		if( first=='/' && second=='*' && third=='*' ) {			commentStarted = 1;			continue;		}		// lines inside comments begin with " *"		int inComment = 0;		if( (first==' ') && (second=='*') )			inComment = 1;		if( inComment && !commentStarted ) {			Abort( "Line starting with \" * \" found outside comment (line %d)", lineNumber );			return 0;		}		if( commentStarted && !inComment ) {			Abort( "Line inside comment does not start with \" * \" (line %d)", lineNumber );			return 0;		}		if( !commentStarted ) continue;		// comments end on lines beginning " */"		if( commentStarted && (first==' ') && (second=='*') && (third=='/') )      {			whichComponent = nextComponent;         nextComponent++;         if( nextComponent == MAX_CLASS_COMPONENTS )            Abort( "Increase MAX_CLASS_COMPONENTS in makedoc.cpp and recompile" );         if( currComponent->IsTerminator() ) {            atEOF = 1;            return 0;         }			currComponent = &componentList[whichComponent];			break;		}		// line containing only " *" signifies start of description		// no more tags after this point		if( OnlyWhitespace(p) )			inDescription = 1;		if( inDescription )			SaveDescriptionLine(p);		else			ParseTag(p);	}	return 1;}// dump summary of every component in listvoid MakeDoc::DebugListComponents(){	ofstream debugf( "complist.txt", ios::app );	debugf << endl;	debugf << "--------------------------------------------------------" << endl;	time_t timer = time(NULL);	struct tm* tblock = localtime(&timer);	debugf << asctime(tblock);	debugf << "--------------------------------------------------------" << endl;   int n = nextComponent;	debugf << "Number of items in componentList: " << n << endl;	debugf << "Index of master component: " << indexOfMaster << endl;	debugf << endl;	for( int i = 0; i < n; i++ )	{		ClassComponent* c = &componentList[i];        debugf << "Component number " << i << ":" << endl;        debugf << "  Type        : ";		switch( c->type ) {			case ClassComponent::CLASS :            	debugf << "CLASS" << endl;            	break;			case ClassComponent::METHOD :            	debugf << "METHOD" << endl;            	break;			case ClassComponent::CONST_METHOD :            	debugf << "CONST_METHOD" << endl;            	break;			case ClassComponent::ENUMERATION :            	debugf << "ENUMERATION" << endl;            	break;			case ClassComponent::MANIP :            	debugf << "MANIP" << endl;            	break;			case ClassComponent::OPERATOR :            	debugf << "OPERATOR" << endl;            	break;			case ClassComponent::CONST_OPERATOR :            	debugf << "CONST_OPERATOR" << endl;            	break;			case ClassComponent::CAST_OPERATOR :            	debugf << "CAST_OPERATOR" << endl;            	break;			case ClassComponent::CONSTRUCTOR :            	debugf << "CONSTRUCTOR" << endl;            	break;			case ClassComponent::DESTRUCTOR :            	debugf << "DESTRUCTOR" << endl;            	break;			case ClassComponent::VARIABLE :            	debugf << "VARIABLE" << endl;            	break;			case ClassComponent::TERMINATOR :            	debugf << "TERMINATOR" << endl;            	break;            default:            	debugf << "Unknown" << endl;        }        debugf << "  Name        : " << c->GetName() << endl;        debugf << "  Return type : " << c->GetReturnType() << endl;        debugf << "  Visibility  : " << c->GetVisibility() << endl;        debugf << endl;	}	debugf.close();}void MakeDoc::WriteComponents(){	int i, j;	outfname = "";	if( strlen(pathname) > 0 ) {		outfname += pathname;			outfname += "\\";	}   if( within.length() > 0 ) {   	outfname += within;      outfname += ".";   }   outfname += className;	outfname += ".html";	outf.open( outfname.c_str() );	cerr << "Creating HTML file " << outfname.c_str() << "..." << endl;	outf << "<html>" << endl;	outf << "<body bgcolor=white>" << endl;	outf << "<h1>Class ";    if( within.length() > 0 ) {    	outf << "<a href=\"" << within.c_str() << ".html\">";        outf << within.c_str() << "</a>::";    }    outf << className;    int numAncestors = classAncestors.size();    if( numAncestors > 0 ) {    	outf << " : ";		for( i = 0; i < numAncestors; i++ ) {			if( i > 0 ) outf << ", ";			outf << "<a href=\"" << classAncestors[i] << ".html\">";			outf << classAncestors[i];            outf << "</a>";		}    }    outf << "</h1>" << endl;	outf << "<dl>";	int numAuthors = classAuthors.size();	if( numAuthors > 0 ) {		if( numAuthors == 1 )			outf << "<dd><b>Author: ";		else			outf << "<dd><b>Authors: ";		for( i = 0; i < numAuthors; i++ ) {			if( i > 0 ) outf << ", ";			outf << classAuthors[i];		}		outf << "</b>" << endl;	}	int numFiles = classFiles.size();	if( numFiles > 0 ) {		if( numFiles == 1 )			outf << "<dd><b>File: ";		else			outf << "<dd><b>Files: ";		for( i = 0; i < numFiles; i++ ) {			if( i > 0 ) outf << ", ";			outf << classFiles[i];		}		outf << "</b>" << endl;	}	outf << "<dd><b>" << classCopyright.c_str() << "</b>" << endl;	outf << "<dd><i>This help file generated automatically by program MakeDoc on " << endl;	time_t timer = time(NULL);	struct tm* tblock = localtime(&timer);	outf << asctime(tblock) << endl;	outf << "</i>" << endl;	outf << "</dl>" << endl;	ClassComponent* master = &componentList[indexOfMaster];	assert( master->IsClass() );	master->GetDescription( outf, ClassComponent::INDEX_ENTRY );   int numSee = seeList.size();	if( numSee > 0 ) {		outf << "<dd><b>See also: ";		for( i = 0; i < numSee; i++ ) {			if( i > 0 ) outf << ", ";			outf << "<a href=\"" << seeList[i] << ".html\">";			outf << seeList[i];			outf << "</a>";		}		outf << "</b>" << endl;	}	//    // Count up the numbers of each type of component and don't output    // anything unless there is something to output	//    int n = whichComponent;    int num_class_components = 0;    int num_variable_components = 0;    int num_enum_components = 0;    int num_constructor_components = 0;    int num_destructor_components = 0;    int num_method_components = 0;    int num_operator_components = 0;    int num_manip_components = 0;    int num_terminator_components = 0;    for( i = 0; i < n; i++ )    {        ClassComponent* c = &componentList[i];        switch( c->type )        {        	case ClassComponent::CLASS :            	num_class_components++;            	break;        	case ClassComponent::VARIABLE :            	num_variable_components++;            	break;        	case ClassComponent::ENUMERATION :            	num_enum_components++;            	break;        	case ClassComponent::CONSTRUCTOR :            	num_constructor_components++;            	break;        	case ClassComponent::DESTRUCTOR :            	num_destructor_components++;            	break;        	case ClassComponent::METHOD :            	num_method_components++;            	break;        	case ClassComponent::CONST_METHOD :            	num_method_components++;            	break;        	case ClassComponent::OPERATOR :            	num_operator_components++;            	break;        	case ClassComponent::CONST_OPERATOR :            	num_operator_components++;            	break;        	case ClassComponent::CAST_OPERATOR :            	num_operator_components++;            	break;        	case ClassComponent::MANIP :            	num_manip_components++;            	break;        	case ClassComponent::TERMINATOR :            	num_terminator_components++;            	break;            default:            	cerr << "unknown component type: " << c->type << endl;        }    }    int num_components = 0;    num_components += num_class_components;    num_components += num_variable_components;    num_components += num_enum_components;    num_components += num_constructor_components;    num_components += num_destructor_components;    num_components += num_method_components;    num_components += num_operator_components;    num_components += num_manip_components;    num_components += num_terminator_components;    assert( n == num_components );	//    // check to make sure this isn't a typedef entry, which will not    // have any components other than the class component (exept    // perhaps a terminator component)	//    int has_components = 1;    if( n == 1 )    	has_components = 0;    if( n == 2 ) {    	int second_is_terminator = ( componentList[1].type == ClassComponent::TERMINATOR );        if(second_is_terminator) has_components = 0;    }    if( !has_components ) {        outf << "</body>" << endl;        outf << "</html>" << endl;        outf.close();        return;    }	outf << "<hr>" << endl;	// variable index    if( num_variable_components > 0 )    {        outf << "<h2>Variable Index</h2>" << endl;        for( i = 0; i < n; i++ )        {            ClassComponent* c = &componentList[i];            if( c->type != ClassComponent::VARIABLE ) continue;            outf << "<a href=\"#" << c->name << "\"><b>";            outf << c->name;            outf << "</b></a><br>";        }    }	// enumeration index	if( num_enum_components > 0 )    {        outf << "<h2>Enumeration Index</h2>" << endl;        outf << "<dl>" << endl;        int whichenum = 1;        for( i = 0; i < n; i++ )        {            ClassComponent* c = &componentList[i];            if( c->type != ClassComponent::ENUMERATION ) continue;            outf << "<dt><b>";            outf << "<a href=\"#enum" << whichenum << "\">";            outf << "enum " << c->name;            c->GetNameExtra(outf);            outf << "</a>";            outf << "</b>" << endl;            whichenum++;        }        outf << "</dl>" << endl;    }	// constructor index	if( num_constructor_components > 0 )    {        outf << "<h2>Constructor Index</h2>" << endl;        outf << "<dl>" << endl;        for( i = 0; i < n; i++ )        {            ClassComponent* c = &componentList[i];            if( c->type != ClassComponent::CONSTRUCTOR ) continue;            outf << "<dt><b>";            c->GetVisibilityAndReturnType(outf);            outf << "<a href=\"#" << c->name << "\">";            outf << c->name;            outf << "</a>";            c->GetNameExtra(outf);            outf << "</b>" << endl;        }        outf << "</dl>" << endl;    }	// destructor index	if( num_destructor_components > 0 )    {        outf << "<h2>Destructor Index</h2>" << endl;        outf << "<dl>" << endl;        for( i = 0; i < n; i++ )        {            ClassComponent* c = &componentList[i];            if( c->type != ClassComponent::DESTRUCTOR ) continue;            outf << "<dt><b>";            c->GetVisibilityAndReturnType(outf);            outf << "<a href=\"#" << c->name << "\">";            outf << c->name;            outf << "</a>";            c->GetNameExtra(outf);            outf << "</b>" << endl;        }        outf << "</dl>" << endl;    }	// method index	if( num_method_components > 0 )    {        outf << "<h2>Method Index</h2>" << endl;        outf << "<dl>" << endl;        for( i = 0; i < n; i++ )        {            ClassComponent* c = &componentList[i];            int ok = ( c->type == ClassComponent::METHOD );            ok = ( ok || ( c->type == ClassComponent::CONST_METHOD ) );            if(!ok) continue;            outf << "<dt><b>";            c->GetVisibilityAndReturnType(outf);            outf << "<a href=\"#" << c->name << "\">";            outf << c->name;            outf << "</a>";            c->GetNameExtra(outf);            outf << "</b>" << endl;        }        outf << "</dl>" << endl;    }	// operator index	if( num_operator_components > 0 )    {		outf << "<h2>Operator Index</h2>" << endl;		outf << "<dl>" << endl;		for( i = 0; i < n; i++ )		{			ClassComponent* c = &componentList[i];            int ok = ( c->type == ClassComponent::OPERATOR );            ok = ( ok || ( c->type == ClassComponent::CAST_OPERATOR ) );            ok = ( ok || ( c->type == ClassComponent::CONST_OPERATOR ) );            if(!ok) continue;			outf << "<dt><b>";			outf << "<a href=\"#" << c->name << "\">";			outf << "operator ";            if( c->type == ClassComponent::CAST_OPERATOR )            	outf << c->GetReturnType();            outf << c->name;            if( c->type == ClassComponent::CONST_OPERATOR )            	outf << " const";			outf << "</a>";			outf << "</b>" << endl;		}		outf << "</dl>" << endl;	}	// manipulator index	if( num_manip_components > 0 )    {		outf << "<h2>Manipulator Index</h2>" << endl;		outf << "<dl>" << endl;		for( i = 0; i < n; i++ )		{			ClassComponent* c = &componentList[i];			if( c->type != ClassComponent::MANIP ) continue;			outf << "<dt><b>";			outf << "<a href=\"#" << c->name << "\">";			outf << c->name;			outf << "</a>";			outf << "</b>" << endl;		}		outf << "</dl>" << endl;	}	outf << "<hr>" << endl;	// variables	if( num_variable_components > 0 )    {        outf << "<h2>Variables</h2>" << endl;        for( i = 0; i < n; i++ )        {            ClassComponent* c = &componentList[i];            if( c->type != ClassComponent::VARIABLE ) continue;            outf << "<a name=\"" << c->name << "\">";            outf << "<img src=\"images/yellowdot.gif\" width=12 height=12 alt=\" o \"></a>";            outf << "<b>  " << c->name << "</b>" << endl;            outf << "<pre><font color=green>";            c->GetVisibilityAndReturnType(outf);            outf << c->name;            c->GetNameExtra(outf);            outf << "</font></pre>" << endl;            c->GetDescription( outf, ClassComponent::FULL_ENTRY );        }    }	// enumerations	if( num_enum_components > 0 )    {        outf << "<h2>Enumerations</h2>" << endl;        int whichenum = 1;        for( i = 0; i < n; i++ )        {            ClassComponent* c = &componentList[i];            if( c->type != ClassComponent::ENUMERATION ) continue;            outf << "<a name=\"enum" << whichenum << "\">";            outf << "<img src=\"images/yellowdot.gif\" width=12 height=12 alt=\" o \"></a>";            outf << "<b>enum " << c->name << "</b>" << endl;            outf << "<pre><font color=green>";            outf << "enum ";            c->GetNameExtra(outf);            outf << "</font>" << endl;            outf << "</pre>" << endl;            c->GetDescription( outf, ClassComponent::FULL_ENTRY );            whichenum++;        }    }	// constructors	if( num_constructor_components > 0 )    {        outf << "<h2>Constructors</h2>" << endl;        for( i = 0; i < n; i++ )        {            ClassComponent* c = &componentList[i];            if( c->type != ClassComponent::CONSTRUCTOR ) continue;            outf << "<a name=\"" << c->name << "\">";            outf << "<img src=\"images/yellowdot.gif\" width=12 height=12 alt=\" o \"></a>";            outf << "<b>  " << c->name << "</b>" << endl;            outf << "<pre><font color=green>";            c->GetVisibilityAndReturnType(outf);            outf << c->name;            c->GetNameExtra(outf);            outf << "</font></pre>" << endl;            c->GetDescription( outf, ClassComponent::FULL_ENTRY );        }    }	// destructor	if( num_destructor_components > 0 )    {        outf << "<h2>Destructor</h2>" << endl;        for( i = 0; i < n; i++ )        {            ClassComponent* c = &componentList[i];            if( c->type != ClassComponent::DESTRUCTOR ) continue;            outf << "<a name=\"" << c->name << "\">";            outf << "<img src=\"images/yellowdot.gif\" width=12 height=12 alt=\" o \"></a>";            outf << "<b>  " << c->name << "</b>" << endl;            outf << "<pre><font color=green>";            c->GetVisibilityAndReturnType(outf);            outf << c->name;            c->GetNameExtra(outf);            outf << "</font></pre>" << endl;            c->GetDescription( outf, ClassComponent::FULL_ENTRY );        }    }	// methods	if( num_method_components > 0 )    {        outf << "<h2>Methods</h2>" << endl;        for( i = 0; i < n; i++ )        {            ClassComponent* c = &componentList[i];            int ok = ( c->type == ClassComponent::METHOD );            ok = ( ok || ( c->type == ClassComponent::CONST_METHOD ) );            if(!ok) continue;            outf << "<a name=\"" << c->name << "\">";            outf << "<img src=\"images/yellowdot.gif\" width=12 height=12 alt=\" o \"></a>";            outf << "<b>  " << c->name << "</b>" << endl;            outf << "<pre><font color=green>";            c->GetVisibilityAndReturnType(outf);            outf << c->name;            c->GetNameExtra(outf);            outf << "</font>" << endl;            int numExceptionClasses = c->throws.size();            for( j = 0; j < numExceptionClasses; j++ ) {                outf << "   <font color=red>throws ";                outf << c->throws[j];                outf << "</font>" << endl;            }            outf << "</pre>" << endl;            c->GetDescription( outf, ClassComponent::FULL_ENTRY );        }    }	// operators	if( num_operator_components > 0 )    {		outf << "<h2>Operators</h2>" << endl;		for( i = 0; i < n; i++ )		{			ClassComponent* c = &componentList[i];            int ok = ( c->type == ClassComponent::OPERATOR );            ok = ( ok || ( c->type == ClassComponent::CAST_OPERATOR ) );            ok = ( ok || ( c->type == ClassComponent::CONST_OPERATOR ) );            if(!ok) continue;			outf << "<a name=\"" << c->name << "\">";			outf << "<img src=\"images/yellowdot.gif\" width=12 height=12 alt=\" o \"></a>";			outf << "<b>  operator " << c->name << "</b>" << endl;			outf << "<pre><font color=green>";			c->GetVisibilityAndReturnType(outf);			outf << "operator ";            if( c->type == ClassComponent::CAST_OPERATOR )            	outf << c->GetReturnType();            outf << c->name;			c->GetNameExtra(outf);			outf << "</font>" << endl;			outf << "</pre>" << endl;			c->GetDescription( outf, ClassComponent::FULL_ENTRY );		}	}	// manipulators	if( num_manip_components > 0 )    {		outf << "<h2>Manipulators</h2>" << endl;		for( i = 0; i < n; i++ )		{			ClassComponent* c = &componentList[i];			if( c->type != ClassComponent::MANIP ) continue;			outf << "<a name=\"" << c->name << "\">";			outf << "<img src=\"images/yellowdot.gif\" width=12 height=12 alt=\" o \"></a>";			outf << "<b>  " << c->name << "</b>" << endl;			c->GetDescription( outf, ClassComponent::FULL_ENTRY );		}	}	outf << "</body>" << endl;	outf << "</html>" << endl;	outf.close();}bool MakeDoc::FileExists( char* fn ){	if( fn == NULL ) 		return false;			bool exists = false;		// I used to use the access function for this, but it doesn't	// seem to exist in the MacIntosh world, so I've reverted to this	// technique, which works for everything	//	FILE* f = fopen( fn, "r" );	if( f != NULL ) {		exists = true;		fclose(f);		f = NULL;	}		return exists;} void MakeDoc::Run( int argc, char* argv[] ){	Init();	if( argc > 2 )		Abort( "wrong number of arguments."			, "Expecting only name of file to parse on command line." );	char infname[256];	strcpy( infname, "testfile.cpp" );	if( argc > 1 )		strcpy( infname, argv[1] );			// chop off file name from path	//	strncpy( pathname, infname, 255 );	char* lastchar = pathname + strlen(infname);	lastchar--;	while( lastchar - pathname > 0 && *lastchar != '\\' )		lastchar--;	*lastchar = '\0';	if( !FileExists( infname ) )		Abort( "file not found -->", infname );	inf.open( infname );	assert(inf);	int ok = FindComment( inf );	if( !ok || className.length() == 0 )		Abort( "class name not found."			, "Expecting first comment to contain @class tag." );	for(;;) {		ok = FindComment( inf );		if(!ok) break;	}   inf.close();	WriteComponents();}int main( int argc, char* argv[] ){   for(;;) {      MakeDoc md;      md.Run( argc, argv );      if( md.AtEndOfFile() ) break;    }   cerr << "Finished." << endl;      //char ch = cin.get();   return 0;}// Example of header comment at the beginning of the file// containing the class being described/** * @class      NxsGDADataBlock * @file       gdadata.h * @file       gdadata.cpp * @author     Paul O. Lewis * @copyright  Copyright � 1996. All Rights Reserved. * @variable   binTable [BinTable:public] holds bin boundaries for vntr data * @variable   data [IndivDataArr:public] the nindivs by nloci data matrix * @variable   datapoint [int:public] see enum for possible states * @variable   flag [int:public] tokens, labels, ignorecase, etc. * @variable   fromBiosys [int:public] if true, data from a BIOSYS data file (1 means data type 1, 2 means data type 2) * @variable   fromGeneStrut [int:public] if true, data from a GeneStrut data file * @variable   fromWeir [int:public] if true, data from a Weir data file * @variable   indivMap [IntArr:public] the ith. cell is row of 1st. indiv. of pop. i * @variable   locusFlag [IntArr:public] determines whether a locus is currently active * @variable   locusLabel [LabelList:public] the locus labels * @variable   locusSet [NxsSet:public] used with include command * @variable   ltable [LTable:public] the locus table, stores allele names * @variable   missing [char:public] the missing data symbol * @variable   nindivs [int:public] the number of individuals * @variable   nloci [int:public] the number of loci * @variable   npops [int:public] the number of populations * @variable   ploidy [IntArr:public] 0 haploid, 1 diploid * @variable   popFlag [IntArr:public] determines whether a population is currently active * @variable   popLabel [LabelList:public] the population labels * @variable   popSet [NxsSet:public] used with include command * @variable   separator [char:public] the character that separates alleles in data matrix * @see        BinTable * @see        IndivDataArr * @see        IntArr * @see        LabelList * @see        LTable * @see        NxsSet * * Encapsulates a GDA data matrix. * Blah, blah, blah, ... */// Example of an enumeration comment/** * @enumeration * @enumitem  respect_case [0x0002] if set, case is respected * @enumitem  fraglen [0x0004] if set, allele names treated as fragment lengths * * For use with the variable flags. */// Example of a constructor comment/** * @constructor * @param nxsDoc [NxsDocBase&] the NxsDocument object that ties GDA together * * Initializes variables such as nloci, npops, nindivs, fromBiosys, * fromWeir, and fromGeneStruct to zero, sets missing to '?' and * separator to '/', sets datapoint to standard, initializes flag * so that 'tokens' and 'labels' are on by default, and tells the * array data that it owns its elements. */// Example of a destructor comment/** * @destructor * * Just calls the Flush method. */// Example of a method comment (no parameters)/** * @method ActivateAllLoci [void:public] * * Calls the function ChgLocusActiveStatus to activate * all loci. */// Example of a method comment (with parameters)/** * @method AddAllele [int:public] * @param name [char*] the name of the allele * @param j [int] the locus * * Adds an allele called name to the LTable object (ltable) * for locus j. If an allele already exists by that name for * that locus, AddAllele returns the value of that allele * (specifically, it returns the value data member of the LNode * object corresponding to that allele in the LTable). * If an allele by that name does not already exist in the * LTable for that locus, then a new LNode is created and added * to the LTable and the value data member of that new node is * returned. */// Example of a method comment (throws exceptions)/** * @method FindTree [int] * @param treeName  [NxsString&]  tree name to find * @throws XNewick * * Searches for a tree having name treeName * returns the index of the tree named treeName * or -1 if tree not found * throws exception if tree list is empty */// Example of an operator comment/** * @operator = [NxsGDADataBlock&:public] * @param gdaData [const NxsGDADataBlock&] the NxsGDADataBlock to be copied * * Copies the information from gdaData to this object. */// Example of a cast operator comment/** * @castoperator () [double:public] * * Casts value of cell to a double. */// Example of a manipulator comment/** * @manipulator setleft * * Specifies the left boundary of the Table body. * All columns added before this point are considered * row headers and will be repeated for each output * page. */