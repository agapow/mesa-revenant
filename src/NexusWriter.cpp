/**************************************************************************
NexusWriter.cpp - formats & pours data to output stream

Credits:
- From SIBIL, the Silwood Biocomputing Library.
- By Paul-Michael Agapow, 2000-2012, Health Protection Agency (UK)
- <mail://pma@agapow.net>
- <http://www.agapow.net/software/mesa>gol

**************************************************************************/


// *** INCLUDES

#include "NexusWriter.h"
#include "TranslationTable.h"
#include "MesaVersion.h"

using sbl::SimpleMatrix;
using std::string;
using std::stringstream;


// *** CONSTANTS & DEFINES

// *** MAIN BODY *********************************************************/

// *** LIFECYCLE *********************************************************/

// *** DATA WRITING *****************************************************/

void NexusWriter::writeDiscData (DiscTraitMatrix& iWrangler)
{
	// Preconditions:
	if (iWrangler.countTaxa() == 0)
		return;
		
	// Main:
	writeBeginBlock ("DATA");
	writeDimensionsCmd (iWrangler.countTaxa(), iWrangler.countChars());
	iWrangler.gatherCharStates ();
	writeFormatCmd ("standard", &(iWrangler.mStates));
	stringvec_t	theCharNames;
	iWrangler.collectColNames (theCharNames);
	writeCharStateLabels (theCharNames);
	writeMatrixCmd (iWrangler);
	writeEndBlock ();
}

void NexusWriter::writeContData (ContTraitMatrix& iWrangler)
{
	// Preconditions:
	if (iWrangler.countTaxa() == 0)
		return;
		
	// Main:
	writeBeginBlock ("CONTINUOUS");
	writeDimensionsCmd (iWrangler.countTaxa(), iWrangler.countChars());
	writeFormatCmd ("continuous");
	stringvec_t	theCharNames;
	iWrangler.collectColNames (theCharNames);
	writeCharStateLabels (theCharNames);
	writeMatrixCmd (iWrangler);
	writeEndBlock ();
}

void NexusWriter::writeTrees (TreeWrangler& iWrangler, bool iWriteTransCmd)
{
	// Preconditions:
	if (iWrangler.size() == 0)
		return;
		
	// Main:
	writeBeginBlock ("TREES");
	TranslationTable theTable;
	TranslationTable* iTranslationP = NULL;
	if (iWriteTransCmd)
	{
		iTranslationP = &theTable;
		iWrangler.calcTranslationTable (iTranslationP);
		writeTranslationCmd (iTranslationP);
	}
	writeTreesCmd (iWrangler, iTranslationP);	
	writeEndBlock ();	
}


void NexusWriter::writeTaxa (stringvec_t& iTaxaNames)
{
	writeBeginBlock ("TAXA");
	mOutStream << "\tDIMENSIONS NTAX=" << iTaxaNames.size() << ";\n";
	mOutStream << "\tTAXLABELS" << "\n";
	stringvec_t::iterator q;
	for (q = iTaxaNames.begin(); q != iTaxaNames.end(); q++)
	{
		mOutStream << "\t\t" << *q << "\n";	
	}
	mOutStream << "\t;" << "\n";
	writeEndBlock ();	
}



// *** WRITING UTILITIES *************************************************/

void NexusWriter::writeHeader ()
//: write a nexus file header
{
	mOutStream << "#NEXUS" << "\n";
	mOutStream << literal("[This file generated by Mesa v") <<
		literal(kMesaVersion) << "]\n";
	mOutStream<< "\n";		
}

void NexusWriter::writeBeginBlock (const char* iBlockString)
{
	mOutStream << "BEGIN " << iBlockString << ";\n";
}

void NexusWriter::writeEndBlock ()
{
	mOutStream << "END;" << "\n";
	mOutStream << "\n";
}


// *** COMMAND WRITING **************************************************/


void NexusWriter::writeDimensionsCmd (int iNumTaxa, int iNumChar)
{
	mOutStream << "\tDIMENSIONS NEWTAXA NTAX=" << iNumTaxa << " NCHAR=" <<
		iNumChar << ";" << "\n";
}

void NexusWriter::writeFormatCmd
(const char* iFormatString, CharStateSet* iStatesP)
//: write out the format command
{	
	mOutStream << "\tFORMAT DATATYPE=" << literal(iFormatString) <<
		" MISSING=? GAP=- ";
	if (iStatesP and iStatesP->size())
		mOutStream << "SYMBOLS=\"" << iStatesP->str() << "\"";
	mOutStream << ";\n";
		
	// mOutStream << " TOKENS"; " NOTOKENS";
	// mOutStream << " SYMBOLS=\"" << literal(theSymbolsP) << "\"";
}


void NexusWriter::writeCharStateLabels (stringvec_t& iCharNames)
{
	// print the header
	mOutStream << "\tCHARSTATELABELS" << "\n";

	// print char names
	for (DiscTraitMatrix::size_type i = 0; i < iCharNames.size(); i++)
	{
		mOutStream << "\t\t" << i + 1 << " \'" << literal (iCharNames[i]) << "\'";
		if (i != (iCharNames.size() - 1))
			mOutStream << ",";
		mOutStream << "\n";
	}
	
	// print the footer
	mOutStream << "\t;" << "\n";

}


void NexusWriter::writeMatrixCmd (DiscTraitMatrix& iWrangler)
{
	// what's the size of the matrix?
	DiscTraitMatrix::size_type theNumTaxa = iWrangler.countTaxa();
	DiscTraitMatrix::size_type theNumChars = iWrangler.countChars();

	// what's the longest taxa name? (so as to format the matrix nicely)
	string::size_type theMaxLabelLen = 0;
	for (DiscTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
	{
		string::size_type theCurrLabelLen = (iWrangler.getRowName(i)).size();
		if (theMaxLabelLen < theCurrLabelLen)
			theMaxLabelLen = theCurrLabelLen;
	}
	
	// print the header
	mOutStream << "\tMATRIX" << "\n";

	// if it is necessary to pad the matrix output, gather the string reps
	SimpleMatrix<string> 	theValueMatrix;
	string::size_type			theMaxSize = 0;
	if (MesaGlobals::mPrefs.mPadNumericOutput == true)
	{
		theValueMatrix.resize (theNumTaxa, theNumChars);
		
		for (DiscTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
		{
			for (DiscTraitMatrix::size_type j = 0; j < theNumChars; j++)
			{
				theValueMatrix[i][j] = iWrangler.at(i,j);
				string::size_type theStrSize = theValueMatrix[i][j].size();
				if (theMaxSize < theStrSize)
					theMaxSize = theStrSize;
			}
		}
		assert (0 < theMaxSize);
		// ... and pad them
		for (DiscTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
		{
			for (DiscTraitMatrix::size_type j = 0; j < theNumChars; j++)
			{
				theValueMatrix[i][j].resize (theMaxSize + 2, ' ');
			}
		}
	}
	
	for (DiscTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
	{
		// print out a padded name
		string 				theCurrName = iWrangler.getRowName(i);
		string::size_type	theCurrLen = theCurrName.size();
		
		mOutStream << "\t\t" << literal (theCurrName);
		for (uint k = theCurrLen; k < theMaxLabelLen + 3; k++)
			mOutStream << ' ';
		
		// print out the character values
		for (DiscTraitMatrix::size_type j = 0; j < theNumChars; j++)
		{
			if (MesaGlobals::mPrefs.mPadNumericOutput == true)
			{
				mOutStream << "\t" << theValueMatrix[i][j];
			}
			else
				mOutStream << "\t" << iWrangler.at(i,j);
		}
		mOutStream << "\n";
	}

	mOutStream << "\t;" << "\n";
}

void NexusWriter::writeMatrixCmd (ContTraitMatrix& iWrangler)
// CHANGE: (01.2.21) the padding of the output with resize (int) must be
// resize (int, char) because otherwise the characters don't get padded.
// Why, I'm unsure.
{
	// what's the size of the matrix?
	ContTraitMatrix::size_type theNumTaxa = iWrangler.countTaxa();
	ContTraitMatrix::size_type theNumChars = iWrangler.countChars();

	// what's the longest taxa name? (so as to format the matrix nicely)
	string::size_type theMaxLabelLen = 0;
	for (ContTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
	{
		string::size_type theCurrLabelLen = (iWrangler.getRowName(i)).size();
		if (theMaxLabelLen < theCurrLabelLen)
			theMaxLabelLen = theCurrLabelLen;
	}
	
	// print the header
	mOutStream << "\tMATRIX" << "\n";
	
	// if it is necessary to pad the matrix output, gather the string reps
	SimpleMatrix<string> 	theNumberMatrix;
	string::size_type			theMaxSize = 0;
	if (MesaGlobals::mPrefs.mPadNumericOutput == true)
	{
		theNumberMatrix.resize (theNumTaxa, theNumChars);
		
		for (ContTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
		{
			for (ContTraitMatrix::size_type j = 0; j < theNumChars; j++)
			{
				char theBuffer[16];
				std::sprintf (theBuffer, "%6f", iWrangler.at(i,j));
				theNumberMatrix[i][j] = theBuffer;
				/*
				stringstream theBuffer;
				theBuffer.width (6);
				theBuffer.precision (6);
				theBuffer << iWrangler.at(i,j);
				theNumberMatrix[i][j] = theBuffer.str();
				*/
				string::size_type theStrSize = theNumberMatrix[i][j].size();
				if (theMaxSize < theStrSize)
					theMaxSize = theStrSize;
			}
		}
		assert (0 < theMaxSize);
		// ... and pad them
		for (ContTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
		{
			for (ContTraitMatrix::size_type j = 0; j < theNumChars; j++)
			{
				theNumberMatrix[i][j].resize (theMaxSize + 2, ' ');
			}
		}
	}
	
	for (ContTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
	{
		// print out a padded name
		string 				theCurrName = iWrangler.getRowName(i);
		string::size_type	theCurrLen = theCurrName.size();
		
		mOutStream << "\t\t" << literal (theCurrName);
		for (uint k = theCurrLen; k < theMaxLabelLen + 3; k++)
			mOutStream << ' ';
		
		// print out the character values
		for (ContTraitMatrix::size_type j = 0; j < theNumChars; j++)
		{
			if (MesaGlobals::mPrefs.mPadNumericOutput == true)
				mOutStream << "\t" << theNumberMatrix[i][j];
			else
				mOutStream << "\t" << iWrangler.at(i,j);
		}
		mOutStream << "\n";
	}

	mOutStream << "\t;" << "\n";
}


void NexusWriter::writeTranslationCmd (TranslationTable* iTableP)
{
	int theSize = iTableP->size();
	mOutStream << "\tTRANSLATE" << "\n";
	for (int i = 1; i <= theSize; i++)
	{
		mOutStream << "\t\t" << i << "\t" <<
			literal (iTableP->getName (i));
		if (i != theSize)
			mOutStream << ",";
		mOutStream << "\n";
	}
	mOutStream << "\t;\n";	
	
}

void NexusWriter::writeTreesCmd (TreeWrangler& iWrangler, TranslationTable* iTableP)
{
	// iterate over all trees
	TreeWrangler::iterator q;
	
	for (q = iWrangler.begin(); q != iWrangler.end(); q++)
	{
		mOutStream << "\tTREE ";
		if (q == iWrangler.getActiveTreeIter())
			mOutStream << "* ";
		mOutStream << literal (q->getTreeName()) << " = [&R] " <<
			literal (q->writeNewick (iTableP)) << ";\n";
	}
}


// *** HELPER FXNS *******************************************************/


NexusWriter& operator << (NexusWriter& iWriter, literal& iFormatCmd)
{
	iWriter.mOutStream << iFormatCmd.mData;
	return iWriter;
}


// *** END ***************************************************************/



