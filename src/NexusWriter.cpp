/**************************************************************************
NexusWriter.cpp - formats & pours data to output stream

Credits:
- From SIBIL, the Silwood Biocomputing Library.
- By Paul-Michael Agapow, 2000-2012, Health Protection Agency (UK)
- <mail://pma@agapow.net>
- <http://www.agapow.net/software/mesa>gol

**************************************************************************/


// *** INCLUDES

#include "NexusWriter.h"
#include "TranslationTable.h"
#include "MesaVersion.h"

using sbl::SimpleMatrix;
using std::string;
using std::stringstream;


// *** CONSTANTS & DEFINES

// *** MAIN BODY *********************************************************/

// *** LIFECYCLE *********************************************************/

// *** DATA WRITING *****************************************************/

void NexusWriter::writeDiscData (DiscTraitMatrix& iWrangler)
{
	// Preconditions:
	if (iWrangler.countTaxa() == 0)
		return;
		
	// Main:
	writeBeginBlock ("DATA");
	writeDimensionsCmd (iWrangler.countTaxa(), iWrangler.countChars());
	iWrangler.gatherCharStates ();
	writeFormatCmd ("standard", &(iWrangler.mStates));
	stringvec_t	theCharNames;
	iWrangler.collectColNames (theCharNames);
	writeCharStateLabels (theCharNames);
	writeMatrixCmd (iWrangler);
	writeEndBlock ();
}

void NexusWriter::writeContData (ContTraitMatrix& iWrangler)
{
	// Preconditions:
	if (iWrangler.countTaxa() == 0)
		return;
		
	// Main:
	writeBeginBlock ("CONTINUOUS");
	writeDimensionsCmd (iWrangler.countTaxa(), iWrangler.countChars());
	writeFormatCmd ("continuous");
	stringvec_t	theCharNames;
	iWrangler.collectColNames (theCharNames);
	writeCharStateLabels (theCharNames);
	writeMatrixCmd (iWrangler);
	writeEndBlock ();
}

void NexusWriter::writeTrees (TreeWrangler& iWrangler, bool iWriteTransCmd)
{
	// Preconditions:
	if (iWrangler.size() == 0)
		return;
		
	// Main:
	writeBeginBlock ("TREES");
	TranslationTable theTable;
	TranslationTable* iTranslationP = NULL;
	if (iWriteTransCmd)
	{
		iTranslationP = &theTable;
		iWrangler.calcTranslationTable (iTranslationP);
		writeTranslationCmd (iTranslationP);
	}
	writeTreesCmd (iWrangler, iTranslationP);	
	writeEndBlock ();	
}


void NexusWriter::writeTaxa (stringvec_t& iTaxaNames)
{
	writeBeginBlock ("TAXA");
	mOutStream << "\tDIMENSIONS NTAX=" << iTaxaNames.size() << ";\n";
	mOutStream << "\tTAXLABELS" << "\n";
	stringvec_t::iterator q;
	for (q = iTaxaNames.begin(); q != iTaxaNames.end(); q++)
	{
		mOutStream << "\t\t" << *q << "\n";	
	}
	mOutStream << "\t;" << "\n";
	writeEndBlock ();	
}



// *** WRITING UTILITIES *************************************************/

void NexusWriter::writeHeader ()
//: write a nexus file header
{
	mOutStream << "#NEXUS" << "\n";
	mOutStream << literal("[This file generated by Mesa v") <<
		literal(kMesaVersion) << "]\n";
	mOutStream<< "\n";		
}

void NexusWriter::writeBeginBlock (const char* iBlockString)
{
	mOutStream << "BEGIN " << iBlockString << ";\n";
}

void NexusWriter::writeEndBlock ()
{
	mOutStream << "END;" << "\n";
	mOutStream << "\n";
}


// *** COMMAND WRITING **************************************************/


void NexusWriter::writeDimensionsCmd (int iNumTaxa, int iNumChar)
{
	mOutStream << "\tDIMENSIONS NEWTAXA NTAX=" << iNumTaxa << " NCHAR=" <<
		iNumChar << ";" << "\n";
}

void NexusWriter::writeFormatCmd
(const char* iFormatString, CharStateSet* iStatesP)
//: write out the format command
{	
	mOutStream << "\tFORMAT DATATYPE=" << literal(iFormatString) <<
		" MISSING=? GAP=- ";
	if (iStatesP and iStatesP->size())
		mOutStream << "SYMBOLS=\"" << iStatesP->str() << "\"";
	mOutStream << ";\n";
		
	// mOutStream << " TOKENS"; " NOTOKENS";
	// mOutStream << " SYMBOLS=\"" << literal(theSymbolsP) << "\"";
}


void NexusWriter::writeCharStateLabels (stringvec_t& iCharNames)
{
	// print the header
	mOutStream << "\tCHARSTATELABELS" << "\n";

	// print char names
	for (DiscTraitMatrix::size_type i = 0; i < iCharNames.size(); i++)
	{
		mOutStream << "\t\t" << i + 1 << " \'" << literal (iCharNames[i]) << "\'";
		if (i != (iCharNames.size() - 1))
			mOutStream << ",";
		mOutStream << "\n";
	}
	
	// print the footer
	mOutStream << "\t;" << "\n";

}


void NexusWriter::writeMatrixCmd (DiscTraitMatrix& iWrangler)
{
	// what's the size of the matrix?
	DiscTraitMatrix::size_type theNumTaxa = iWrangler.countTaxa();
	DiscTraitMatrix::size_type theNumChars = iWrangler.countChars();

	// what's the longest taxa name? (so as to format the matrix nicely)
	string::size_type theMaxLabelLen = 0;
	for (DiscTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
	{
		string::size_type theCurrLabelLen = (iWrangler.getRowName(i)).size();
		if (theMaxLabelLen < theCurrLabelLen)
			theMaxLabelLen = theCurrLabelLen;
	}
	
	// print the header
	mOutStream << "\tMATRIX" << "\n";

	// if it is necessary to pad the matrix output, gather the string reps
	SimpleMatrix<string> 	theValueMatrix;
	string::size_type			theMaxSize = 0;
	if (MesaGlobals::mPrefs.mPadNumericOutput == true)
	{
		theValueMatrix.resize (theNumTaxa, theNumChars);
		
		for (DiscTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
		{
			for (DiscTraitMatrix::size_type j = 0; j < theNumChars; j++)
			{
				theValueMatrix[i][j] = iWrangler.at(i,j);
				string::size_type theStrSize = theValueMatrix[i][j].size();
				if (theMaxSize < theStrSize)
					theMaxSize = theStrSize;
			}
		}
		assert (0 < theMaxSize);
		// ... and pad them
		for (DiscTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
		{
			for (DiscTraitMatrix::size_type j = 0; j < theNumChars; j++)
			{
				theValueMatrix[i][j].resize (theMaxSize + 2, ' ');
			}
		}
	}
	
	for (DiscTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
	{
		// print out a padded name
		string 				theCurrName = iWrangler.getRowName(i);
		string::size_type	theCurrLen = theCurrName.size();
		
		mOutStream << "\t\t" << literal (theCurrName);
		for (int k = theCurrLen; k < theMaxLabelLen + 3; k++)
			mOutStream << ' ';
		
		// print out the character values
		for (DiscTraitMatrix::size_type j = 0; j < theNumChars; j++)
		{
			if (MesaGlobals::mPrefs.mPadNumericOutput == true)
			{
				mOutStream << "\t" << theValueMatrix[i][j];
			}
			else
				mOutStream << "\t" << iWrangler.at(i,j);
		}
		mOutStream << "\n";
	}

	mOutStream << "\t;" << "\n";
}

void NexusWriter::writeMatrixCmd (ContTraitMatrix& iWrangler)
// CHANGE: (01.2.21) the padding of the output with resize (int) must be
// resize (int, char) because otherwise the characters don't get padded.
// Why, I'm unsure.
{
	// what's the size of the matrix?
	ContTraitMatrix::size_type theNumTaxa = iWrangler.countTaxa();
	ContTraitMatrix::size_type theNumChars = iWrangler.countChars();

	// what's the longest taxa name? (so as to format the matrix nicely)
	string::size_type theMaxLabelLen = 0;
	for (ContTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
	{
		string::size_type theCurrLabelLen = (iWrangler.getRowName(i)).size();
		if (theMaxLabelLen < theCurrLabelLen)
			theMaxLabelLen = theCurrLabelLen;
	}
	
	// print the header
	mOutStream << "\tMATRIX" << "\n";
	
	// if it is necessary to pad the matrix output, gather the string reps
	SimpleMatrix<string> 	theNumberMatrix;
	string::size_type			theMaxSize = 0;
	if (MesaGlobals::mPrefs.mPadNumericOutput == true)
	{
		theNumberMatrix.resize (theNumTaxa, theNumChars);
		
		for (ContTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
		{
			for (ContTraitMatrix::size_type j = 0; j < theNumChars; j++)
			{
				char theBuffer[16];
				std::sprintf (theBuffer, "%6f", iWrangler.at(i,j));
				theNumberMatrix[i][j] = theBuffer;
				/*
				stringstream theBuffer;
				theBuffer.width (6);
				theBuffer.precision (6);
				theBuffer << iWrangler.at(i,j);
				theNumberMatrix[i][j] = theBuffer.str();
				*/
				string::size_type theStrSize = theNumberMatrix[i][j].size();
				if (theMaxSize < theStrSize)
					theMaxSize = theStrSize;
			}
		}
		assert (0 < theMaxSize);
		// ... and pad them
		for (ContTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
		{
			for (ContTraitMatrix::size_type j = 0; j < theNumChars; j++)
			{
				theNumberMatrix[i][j].resize (theMaxSize + 2, ' ');
			}
		}
	}
	
	for (ContTraitMatrix::size_type i = 0; i < theNumTaxa; i++)
	{
		// print out a padded name
		string 				theCurrName = iWrangler.getRowName(i);
		string::size_type	theCurrLen = theCurrName.size();
		
		mOutStream << "\t\t" << literal (theCurrName);
		for (int k = theCurrLen; k < theMaxLabelLen + 3; k++)
			mOutStream << ' ';
		
		// print out the character values
		for (ContTraitMatrix::size_type j = 0; j < theNumChars; j++)
		{
			if (MesaGlobals::mPrefs.mPadNumericOutput == true)
				mOutStream << "\t" << theNumberMatrix[i][j];
			else
				mOutStream << "\t" << iWrangler.at(i,j);
		}
		mOutStream << "\n";
	}

	mOutStream << "\t;" << "\n";
}


void NexusWriter::writeTranslationCmd (TranslationTable* iTableP)
{
	int theSize = iTableP->size();
	mOutStream << "\tTRANSLATE" << "\n";
	for (int i = 1; i <= theSize; i++)
	{
		mOutStream << "\t\t" << i << "\t" <<
			literal (iTableP->getName (i));
		if (i != theSize)
			mOutStream << ",";
		mOutStream << "\n";
	}
	mOutStream << "\t;\n";	
	
}

void NexusWriter::writeTreesCmd (TreeWrangler& iWrangler, TranslationTable* iTableP)
{
	// iterate over all trees
	TreeWrangler::iterator q;
	
	for (q = iWrangler.begin(); q != iWrangler.end(); q++)
	{
		mOutStream << "\tTREE ";
		if (q == iWrangler.getActiveTreeIter())
			mOutStream << "* ";
		mOutStream << literal (q->getTreeName()) << " = [&R] " <<
			literal (q->writeNewick (iTableP)) << ";\n";
	}
}


// *** HELPER FXNS *******************************************************/


NexusWriter& operator << (NexusWriter& iWriter, literal& iFormatCmd)
{
	iWriter.mOutStream << iFormatCmd.mData;
	return iWriter;
}


// *** DEPRECATED & DEBUG ***********************************************/

// these all check that the block is not null


/*
void NexusWriter::writeTaxa (MyTaxaBlock* iTaxaP)
{
	if (iTaxaP == NULL)	// if there's nothing to print
		return;

	writeBeginBlock (iTaxaP);
	writeDimensionsCmd (iTaxaP);
	writeTaxlabelsCmd (iTaxaP);
	writeEndBlock ();
}


void NexusWriter::writeDiscrete (MyCharactersBlock* iDiscreteP)
{
	// Preconditions & argument interpretation:
	if (iDiscreteP == NULL)	// if there's nothing to print
		return;
	assert (iDiscreteP->GetDataType() ==
		iDiscreteP->CharactersBlock::standard);

	// Main:
	writeBeginBlock (iDiscreteP);
	writeDimensionsCmd (iDiscreteP);
	writeFormatCmd (iDiscreteP);		
	writeCharLabelsCmd (iDiscreteP);
	writeMatrixCmd (iDiscreteP);
	writeEndBlock ();
}


void NexusWriter::writeContinuous (MyCharactersBlock* mContinuousP)
{
	// Preconditions & argument interpretation:
	if (mContinuousP == NULL)	// if there's nothing to print
		return;
	assert (mContinuousP->GetDataType() ==
		mContinuousP->CharactersBlock::continuous);
		
	// Main:
	writeBeginBlock (mContinuousP);
	writeDimensionsCmd (mContinuousP);
	writeFormatCmd (mContinuousP);		
	writeMatrixCmd (mContinuousP);
	writeEndBlock ();
}


void NexusWriter::writeTrees (MyTreesBlock* mTreesP)
{
	// Preconditions & argument interpretation:
	if (mTreesP == NULL)	// if there's nothing to print
		return;
		
	// Main:
	writeBeginBlock (mTreesP);
	mTreesP->calcTranslationTable();
	writeTranslationCmd (mTreesP);
	writeTreesCmd (mTreesP);	
	writeEndBlock ();	
}


void NexusWriter::writeBeginBlock (NexusBlock* iBlockP)
{
	mOutStream << "BEGIN " << iBlockP->GetID() << ";\n";
}


// *** CHARACTER BLOCKS
void NexusWriter::writeDimensionsCmd (TaxaBlock* iTaxaP)
//: write out the dimensions statement for a taxa block
{
	mOutStream << "\tDIMENSIONS NTAX=" << iTaxaP->GetNumTaxonLabels() <<
		";" << "\n";
}

void NexusWriter::writeDimensionsCmd (CharactersBlock* iCharactersP)
//: write out the dimensions statement for a characters/data block
{
	int theNumTaxa = iCharactersP->GetNTax();
	int theNumChars = iCharactersP->GetNChar();			
	mOutStream << "\tDIMENSIONS NTAX=" << theNumTaxa << " NCHAR=" <<
		theNumChars << ";" << "\n";
}

void NexusWriter::writeFormatCmd (CharactersBlock* iCharactersP)
//: write out the format statement
{	
	int	theDataType = iCharactersP->GetDataType();
	mOutStream << "\tFORMAT DATATYPE=";
	switch (theDataType)
	{
		case CharactersBlock::standard:
			mOutStream << literal("standard");
			break;
		case CharactersBlock::dna:
			mOutStream << literal("dna");
			break;
		case CharactersBlock::rna:
			mOutStream << literal("rna");
			break;
		case CharactersBlock::nucleotide:
			mOutStream << literal("nucleotide");
			break;
		case CharactersBlock::protein:
			mOutStream << literal("protein");
			break;
		case CharactersBlock::continuous:
			mOutStream << literal("continuous");
			break;
		default:
			assert ("should never reach here" == false);
	}

	char theMissingSym = iCharactersP->GetMissingSymbol();
	if (theMissingSym != '\0')
		mOutStream << " MISSING=" << literal(theMissingSym);
		
	char theGapSymbol = iCharactersP->GetGapSymbol();
	if (theGapSymbol != '\0')
		mOutStream << " GAP=" << literal(theGapSymbol);
	
	if (iCharactersP->IsTokens ())
		mOutStream << " TOKENS";
	else
		mOutStream << " NOTOKENS";
	
	char* theSymbolsP = iCharactersP->GetSymbols();
	if (theSymbolsP != NULL)
		mOutStream << " SYMBOLS=\"" << literal(theSymbolsP) << "\"";
	
	mOutStream << ";" << "\n";
}


void NexusWriter::writeCharLabelsCmd (CharactersBlock* iCharactersP)
{
/*
	if (0 <  iCharactersP->charLabels.size())
	{
		mOutStream << "\tCHARSTATELABELS" << "\n";
		for (int k = 0; k < iCharactersP->GetNChar(); k++)
		{
			// grab the label string
			mOutStream << "\t\t" << (1 +
				iCharactersP->GetOrigCharIndex(k)) << "\t";
			string theLabel (iCharactersP->charLabels[llistsz_t (k)].c_str());
			
			if (theLabel.length() == 0 )
			{
				// if it fdoesn't exists, say so
				 mOutStream << "\'(no label provided)\'" << "\n";
			}
			else
			{
				mOutStream << "\'" << literal(theLabel) << "\' /";

				// output state labels if any defined for this character
	         LabelListBag::const_iterator p = iCharactersP->charStates.find (k);
	         if (p != iCharactersP->charStates.end())
	         {
	            int ns = int ((*p).second.size());
	            for (int m = 0; m < ns; m++)
	            {
	            	string theStates (((*p).second[llistsz_t (m)]).c_str());
						if (sbl::isMemberOf (' ', theStates))
						{
							theStates.insert(0, "\'");
							theStates.append("\'");
						}				            	
	         		mOutStream << " " << literal(theStates);
	            }
	            mOutStream << "\n";
	         }
			}		
					
		}
		
		mOutStream << "\t;" << "\n";
	}
}

void NexusWriter::writeMatrixCmd (CharactersBlock* iCharactersP)
// ( ostream& out, char* marginText )
{
	mOutStream << "\tMATRIX" << "\n";
	int width = iCharactersP->taxa.GetMaxTaxonLabelLength();

	for (int i = 0; i < iCharactersP->ntaxTotal; i++ )
	{
		// Grab taxon name from taxa block
		// Taxa may not have been presented in the matrix in the same order
		// as they were stored in the taxa block, so use taxonPos array to
		// spit them out in the order they appeared in the TAXA command.
		// If the taxonPos cell is -1, then that means there is no row of
		// the data matrix corresponding to that taxon

		if (iCharactersP->taxonPos[i] < 0)
			continue;
		else
		{
			mOutStream << "\t\t";
			nxsstring currTaxonLabel = iCharactersP->taxa.GetTaxonLabel(iCharactersP->taxonPos[i]);
			replace (currTaxonLabel.begin(), currTaxonLabel.end(),
				' ', '_');
			mOutStream << literal(currTaxonLabel);

			// print out enough spaces to even up the left edge of the matrix output
			int currTaxonLabelLen = int (currTaxonLabel.size()); // PMA
			int diff = width - currTaxonLabelLen;
			for (int k = 0; k < diff+5; k++ )
				mOutStream << ' ';
		}

		for (int currChar = 0; currChar < iCharactersP->ncharTotal; currChar++)
		{
         int j = iCharactersP->charPos[currChar];
         if (j < 0)
         	continue;
         stringstream theOutString;
			iCharactersP->ShowStateLabels (theOutString, i, j);
			mOutStream << theOutString.str();
		}

		mOutStream << "\n";
	}
	mOutStream << "\t;" << "\n";
}
 

void NexusWriter::writeTaxlabelsCmd (TaxaBlock* iTaxaP)
{
	mOutStream << "\tTAXLABELS" << "\n";
	int theNumTaxa = iTaxaP->GetNumTaxonLabels();
	for (int i = 0; i < theNumTaxa; i++)
	{
		nxsstring currTaxonLabel =iTaxaP->GetTaxonLabel(i);
		//replace (currTaxonLabel.begin(), currTaxonLabel.end(), ' ', '_');

		mOutStream << "\t\t\'" << literal(currTaxonLabel) << "\'\n";
	}
	mOutStream << "\t;" << "\n";
}


// *** TREE BLOCKS
void NexusWriter::writeTranslationCmd (MyTreesBlock* iTreesP)
{
	TranslationTable::size_type theSize = iTreesP->countTaxa();
	mOutStream << "\tTRANSLATE" << "\n";
	for (TranslationTable::size_type i = 1; i <= theSize; i++)
	{
		mOutStream << "\t\t" << i << "\t" << literal (iTreesP->mTable.getName (int(i)));
		if (i != theSize)
			mOutStream << ",";
		mOutStream << "\n";
	}
	mOutStream << "\t;\n";	
}

void NexusWriter::writeTreesCmd (MyTreesBlock* iTreesP)
{
	MyTreesBlock::size_type theNum = iTreesP->countTrees();
	MyTreesBlock::size_type theDefIndex = sbl::ulong (iTreesP->GetNumDefaultTree());
	
	for (MyTreesBlock::size_type i = 0; i < theNum; i++)
	{
		mOutStream << "\tTREE " << literal((iTreesP->refTree(i)).mName) <<
			" ";	
		if (i == theDefIndex)
			mOutStream << "* ";
		mOutStream << "= [&R] " << iTreesP->getTreeRep (i) << ";\n";
	}
	
}
*/

// *** END ***************************************************************/



