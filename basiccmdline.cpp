#include <strstream>#include <fstream.h>#include <iomanip.h>#include <unistd.h>#include <stdio.h>#include "nexusdefs.h"#include "xnexus.h"#include "nexustoken.h"#include "nexus.h"#include "taxablock.h"#include "assumptionsblock.h"#include "treesblock.h"#include "discretedatum.h"#include "discretematrix.h"#include "charactersblock.h"#include "basiccmdline.h"/** * @class      BASICCMDLINE * @file       basiccmdline.h * @file       basiccmdline.cpp * @author     Paul O. Lewis * @copyright  Copyright ï¿½ 1999. All Rights Reserved. * @variable   command_maxlen [static int] maximum length of a command entered interactively by user * @variable   inf_open [bool] true iff inf is currently open * @variable   message [nxsstring] workspace for composing output strings * @variable   next_command [char*] workspace for processing next command entered interactively by user * @variable   logf [ofstream] the log file stream * @variable   logf_open [bool] true iff logf is currently open * @variable   quit_now [bool] set to false at beginning of Run and turns true only when QUIT command processed * @see        Nexus * @see        NexusBlock * @see        NexusReader * @see        NexusToken * @see        XNexus * * <pre> * +---- Remove these comments for an actual implementation --------------------------+ * |                                                                                  | * | BASICCMDLINE provides a template for creating a program that reads NEXUS data    | * | files and provides a basic command line.  After compiling BASICCMDLINE, you will | * | already have a program that understands the following commands, either typed in  | * | at the console or provided in a BASICCMDLINE block in a NEXUS data file          | * | (exception is the execute command, which can only be entered at the console).    | * | Keywords in the descriptions below are given in uppercase, however the           | * | commands themselves are case-insensitive.  Lower-case indicates a parameter      | * | supplied by the user (e.g., "filename" would be replaced by the actual           | * | name of the file). Square brackets indicate optional keywords or subcommands.    | * |                                                                                  | * | EXECUTE filename;                                                                | * |                                                                                  | * | LOG [options];                                                                   | * |                                                                                  | * |   Option         Action                                                          | * |   ------------------------------------------------------                         | * |   FILE=filename  specifies name of log file to start                             | * |   START          indicates logging is to be started                              | * |   STOP           indicates logging is to be stopped                              | * |   APPEND         append to log file if it already exists                         | * |   REPLACE        replace log file without asking                                 | * |                                                                                  | * | QUIT;                                                                            | * |                                                                                  | * | See the Read function for details and to add other commands.                     | * |                                                                                  | * | To change the name of the program (which is also the prompt name and the         | * | name of the program's private NEXUS block), replace all occurrences of           | * | BASICCMDLINE with the name of your program (also search for the string           | * | "basiccmdline" and replace with an appropriate string at each occurrence).       | * |                                                                                  | * +----------------------------------------------------------------------------------+  * </pre> * * This class handles reading and storage for the Nexus block BASICCMDLINE. * It also serves as the main class for the program BASICCMDLINE, acting  * as a Nexus object (in order to be capable of parsing data files) * as well as a NexusBlock object (in order to be able to process * commands in a BASICCMDLINE block).  * * Acting as a NexusBlock. it overrides the member functions  * Read and Reset, which are abstract virtual functions in  * the base class NexusBlock. * * Acting as a Nexus object, it overrides the member functions * EnteringBlock, SkippingBlock, and NexusError. *//** * @constructor * * Initializes the id data member to "BASICCMDLINE" and calls the FactoryDefaults * member function to perform the remaining initializations. */BASICCMDLINE::BASICCMDLINE(){	id = "BASICCMDLINE";	FactoryDefaults();}/** * @destructor * * Closes logf if it is open. */BASICCMDLINE::~BASICCMDLINE(){	if( logf_open )		logf.close();}/** * @method CharLabelToNumber [int:protected] * @param s [nxsstring] the character label to be translated to character number * * The code here is identical to the base class version (simply returns 0), * so the code here should either be modified or this derived version * eliminated altogether.  Under what circumstances would you need to * modify the default code, you ask?  This function should be modified * to something meaningful if this derived class needs to construct and * run a SetReader object to read a set involving characters.  The SetReader * object may need to use this function to look up a character label * encountered in the set.  A class that overrides this method should * return the character index in the range [1..nchar]; i.e., add one to the * 0-offset index. */int BASICCMDLINE::CharLabelToNumber( nxsstring /*s*/ ){   return 0;}/** * @method EnteringBlock [virtual void:public] * @param blockName [nxsstring] the name of the block just entered * * Called by the Nexus object when a block named blockName is entered. * Allows program to notify user of progress in parsing the NEXUS file. * Virtual function that overrides the pure virtual function in the * base class Nexus. */void BASICCMDLINE::EnteringBlock( nxsstring blockName ){	message = "Reading ";	message += blockName;	message += " block...";	PrintMessage();}/** * @method ExitingBlock [virtual void:public] * @param blockName [nxsstring] the name of the block just exited * * Called by the Nexus object when exiting a block named blockName. * Allows program to notify user of progress in parsing the NEXUS file. * Virtual function that overrides the pure virtual function in the * base class Nexus. */void BASICCMDLINE::ExitingBlock( nxsstring /*blockName*/ ){}/** * @method FactoryDefaults [void:protected] * * Sets all data members to their factory default settings: * <table> * <tr><th align="left">Variable <th> <th align="left"> Initial Value * <tr><td> inf_open          <td>= <td> false * <tr><td> logf_open         <td>= <td> false * <tr><td> quit_now          <td>= <td> false * <tr><td> message           <td>= <td> "" * <tr><td> next_command[0]   <td>= <td> '\0' * <tr><td> trees             <td>= <td> NULL * <tr><td> taxa              <td>= <td> NULL * <tr><td> assumptions       <td>= <td> NULL * <tr><td> characters        <td>= <td> NULL * </table> */void BASICCMDLINE::FactoryDefaults(){	inf_open = false;	logf_open = false;	quit_now = false;	message = "";	next_command[0] = '\0';		trees = NULL;	taxa = NULL;	assumptions = NULL;	characters = NULL;}/** * @method FileExists [bool:protected] * @param fn [const char*] the name of the file to check * * Returns true if file named fn already exists,  * false otherwise. */bool BASICCMDLINE::FileExists( const char* fn ){	bool exists = false;	//	if( access( fn, 0 ) == 0 )//		exists = true;	FILE* fp = fopen( fn, "r" );	if( fp != NULL ) {		fclose(fp);		exists = true;	}			return exists;}/** * @method HandleEndblock [nxsstring:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Called whenever a file name needs to be read from either * the command line or a file.  Expects next token to be "=" * followed by the token representing the file name.  Call * this function after, say, the keyword "file" has been  * read in the following LOG command: * <pre> * log file=doofus.txt start replace; * </pre> * Note that this function will read only "=doofus.txt " * leaving "start replace;" in the stream for reading * at a later time. */nxsstring BASICCMDLINE::GetFileName( NexusToken& token ){	// Eat the equals sign	//	token.GetNextToken();		if( !token.Equals("=") ) {		errormsg = "Expecting an equals sign, but found ";      errormsg += token.GetToken();      errormsg += " instead";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}		// Now get the filename itself	//	token.GetNextToken();		return token.GetToken();}/** * @method HandleEndblock [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Called when the END or ENDBLOCK command needs to be parsed * from within the BASICCMDLINE block.  Basically just checks to make * sure the next token in  the data file is a semicolon. */void BASICCMDLINE::HandleEndblock( NexusToken& token ){	// get the semicolon following END or ENDBLOCK token   //	token.GetNextToken();		if( !token.Equals(";") ) {		errormsg = "Expecting ';' to terminate the END or ENDBLOCK command, but found ";      errormsg += token.GetToken();      errormsg += " instead";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}}/** * @method HandleExecute [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Handles everything after the EXecute keyword and the terminating * semicolon.  Flushes all blocks before executing file specified, * and no warning is given of this */void BASICCMDLINE::HandleExecute( NexusToken& token ){	// Issuing the EXECUTE command from within a file is a no-no   //	if( inf_open ) {		errormsg = "Cannot issue execute command from within a BASICCMDLINE block";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}		// Get the file name to execute   //	token.GetNextToken();		nxsstring fn = token.GetToken();	// get the semicolon terminating the EXECUTE command   //	token.GetNextToken();		if( !token.Equals(";") ) {		errormsg = "Expecting ';' to terminate the EXECUTE command, but found ";      errormsg += token.GetToken();      errormsg += " instead";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}	// Before going through with this, make sure we're not going to overwrite 	// any stored blocks	bool stuff_stored = !taxa->IsEmpty();	stuff_stored = ( stuff_stored || !trees->IsEmpty() );	stuff_stored = ( stuff_stored || !assumptions->IsEmpty() );	stuff_stored = ( stuff_stored || !characters->IsEmpty() );	if( stuff_stored && UserSaysOk( "Ok to delete?", "Data has already been read and stored" ) )		PurgeBlocks();	else if( stuff_stored ) {		message = "\nExecute command aborted.";		PrintMessage();		return;	}		if( FileExists( fn.c_str() ) )	{		cerr << endl;		cerr << "Opening " << fn << "..." << endl;				ifstream inf( fn.c_str(), ios::binary | ios::in );				inf_open = true;			NexusToken ftoken(inf);			try {			Execute( ftoken );		}		catch( XNexus x ) 		{			NexusError( errormsg, x.pos, x.line, x.col );	      Reset();		}				if( inf_open )			inf.close();		inf_open = false;				if( !taxa->IsEmpty() ) {			cerr << "  TAXA block found" << endl;			if( logf_open )				taxa->Report(logf);		}			if( !trees->IsEmpty() ) {			cerr << "  TREES block found" << endl;			if( logf_open )				trees->Report(logf);		}			if( !assumptions->IsEmpty() ) {			cerr << "  ASSUMPTIONS block found" << endl;			if( logf_open )				assumptions->Report(logf);		}			if( !characters->IsEmpty() ) {			cerr << "  CHARACTERS block found" << endl;			if( logf_open )				characters->Report(logf);		}	}	else	{		cerr << endl;		cerr << "Oops! Could not find specified file: " << fn << endl;	}}/** * @method HandleHelp [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Called when the HELP command needs to be parsed * from within the BASICCMDLINE block. */void BASICCMDLINE::HandleHelp( NexusToken& token ){	// Retrieve all tokens for this command, stopping only in the event	// of a semicolon or an unrecognized keyword	//	for(;;)	{		token.GetNextToken();		if( token.Equals(";") ) {			break;		}		else {			errormsg = "Unexpected keyword (";	      errormsg += token.GetToken();	      errormsg += ") encountered reading HELP command";			throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}   }      message = "\nExamples of use of available commands:";   message += "\n  help                     -> shows this message";   message += "\n  log file=mylog.txt start -> opens log file named mylog.txt";   message += "\n  log stop                 -> closes current log file";   message += "\n  exe mydata.nex           -> executes nexus file mydata.nex";   message += "\n  show                     -> reports on blocks currently stored";   message += "\n  quit                     -> terminates application";   message += "\n";   PrintMessage();}/** * @method HandleShow [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Called when the HELP command needs to be parsed * from within the BASICCMDLINE block. */void BASICCMDLINE::HandleShow( NexusToken& token ){	// Retrieve all tokens for this command, stopping only in the event	// of a semicolon or an unrecognized keyword	//	for(;;)	{		token.GetNextToken();		if( token.Equals(";") ) {			break;		}		else {			errormsg = "Unexpected keyword (";	      errormsg += token.GetToken();	      errormsg += ") encountered reading HELP command";			throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}   }      message = "\nNexus blocks currently stored:";   PrintMessage();	if( !taxa->IsEmpty() ) {		cerr << "\n  TAXA block found" << endl;		taxa->Report(cerr);		if( logf_open )			taxa->Report(logf);	}	if( !trees->IsEmpty() ) {		cerr << "\n  TREES block found" << endl;		trees->Report(cerr);		if( logf_open )			trees->Report(logf);	}	if( !assumptions->IsEmpty() ) {		cerr << "\n  ASSUMPTIONS block found" << endl;		assumptions->Report(cerr);		if( logf_open )			assumptions->Report(logf);	}	if( !characters->IsEmpty() ) {		cerr << "\n  CHARACTERS block found" << endl;		characters->Report(cerr);		if( logf_open )			characters->Report(logf);	}}/** * @method HandleLog [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * Called when the LOG command needs to be parsed * from within the BASICCMDLINE block. */void BASICCMDLINE::HandleLog( NexusToken& token ){	bool starting = false;	bool stopping = false;	bool appending = false;	bool replacing = false;	bool name_provided = false;	nxsstring logfname;		// Retrieve all tokens for this command, stopping only in the event	// of a semicolon or an unrecognized keyword	//	for(;;)	{		token.GetNextToken();		if( token.Equals(";") ) {			break;		}		else if( token.Abbreviation("STOp") ) {			stopping = true;		}		else if( token.Abbreviation("STArt") ) {			starting = true;		}		else if( token.Abbreviation("Replace") ) {			replacing = true;		}		else if( token.Abbreviation("Append") ) {			appending = true;		}		else if( token.Abbreviation("File") ) {			logfname = GetFileName(token);			name_provided = true;		}		else {			errormsg = "Unexpected keyword (";	      errormsg += token.GetToken();	      errormsg += ") encountered reading LOG command";			throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );		}   }      // Check for incompatible combinations of keywords   //   if( stopping && ( starting || appending || replacing || name_provided ) ) {		errormsg = "Cannot specify STOP with any of the following START, APPEND, REPLACE, FILE";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );   }      if( appending && replacing ) {		errormsg = "Cannot specify APPEND and REPLACE at the same time";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );   }   if( logf_open && ( starting || name_provided || appending || replacing ) ) {		errormsg = "Cannot start log file since log file is already open";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );   }   // Is user closing an open log file?   //   if( stopping ) {		logf.close();		logf_open = false;				message = "\nLog file closed";		PrintMessage();				return;   }   	// If this far, must be attempting to open a log file	//	if( !name_provided ) {		errormsg = "Must provide a file name when opening a log file\n";		errormsg += "e.g., log file=doofus.txt start replace;";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}   		if( appending ) {		logf_open = true;		logf.open( logfname.c_str(), ios::out | ios::app );		message = "\nAppending to log file ";		message += logfname;		PrintMessage();	}	else if( replacing ) {		logf_open = true;		logf.open( logfname.c_str() );		message = "\nReplacing log file ";		message += logfname;		PrintMessage();	}	else  {		bool exists = FileExists( logfname.c_str() );		bool userok = true;		if( exists && !UserSaysOk( "Ok to replace?", "Log file specified already exists" ) )			userok = false;		if( userok ) {			logf_open = true;			logf.open( logfname.c_str() );		}		if( exists && userok ) {			message = "\nReplacing log file ";			message += logfname;		}		else if( userok ) {			message = "\nLog file ";			message += logfname;			message += " opened";		}		else {			message = "\nLog command aborted";		}		PrintMessage();	}}/** * @method PreprocessNextCommand [void:public] * * Accepts a string in the form of a BASICCMDLINE block containing one command * and processes it just like a real BASICCMDLINE block in a NEXUS data file. */void BASICCMDLINE::HandleNextCommand(){	std::istrstream cmdin( next_command ); ///	NexusToken token(cmdin);	try {		Read( token );	}	catch( XNexus x ) 	{		NexusError( errormsg, x.pos, x.line, x.col );      Reset();	}}/** * @method NexusError [virtual void:public] * @param msg [nxsstring&] the error message * @param pos [streampos] the point in the NEXUS file where the error occurred * @param line [long] the line in the NEXUS file where the error occurred * @param col [long] the column in the NEXUS file where the error occurred * * Called when an error is encountered in a NEXUS file. Allows program to * give user details of the error as well as the precise location of the * error. Virtual function that overrides the pure virtual function in the * base class Nexus. */void BASICCMDLINE::NexusError( nxsstring& msg, ncl_streampos /* pos */, long line, long col ){	message = "\n";	message += msg;	PrintMessage();		if( inf_open )	{		message = "Line:   ";		message += line;		PrintMessage();			message = "Column: ";		message += col;		PrintMessage();	}}/** * @method PreprocessNextCommand [void:public] * * Begins with the command just entered by the user, which is stored in * the data member next_command, adds a semicolon (if the user failed * to supply one), and then adds "end;" so the whole bundle looks * like a very short BASICCMDLINE block.  This is then passed to HandleNextCommand, * which processes it just like a real BASICCMDLINE block in a NEXUS data file. */void BASICCMDLINE::PreprocessNextCommand(){	// If user failed to add the terminating semicolon,	// we'll do it now. We will also remove the line feed	// at the end and add the command "end;" to the end	// of the line (see explanation below).	//	int len = strlen(next_command);	assert( len > 0 );	// Remove any whitespace characters from end of string entered by user	//	int i = len;	while( i > 0 && next_command[i-1] == ' ' || next_command[i-1] == '\t' || next_command[i-1] == '\n' )		i--;	// If character at position i-1 is a semicolon, put '\0' terminator at position i;	// otherwise, put a semicolon at position i and terminator at i+1	//	if( next_command[i-1] != ';' ) {		next_command[i] = ';';		i++;	}	assert( i <= COMMAND_MAXLEN );	next_command[i] = '\0';		// Now add a semicolon at the beginning and terminate with an "END;" command 	// so that we can pretend this is simply a very short private NEXUS block	// containing only one command.  This allows us to simply use the Read 	// function we inherited from the base class BstBase to process the command.	//	len = strlen(next_command);	assert( len < COMMAND_MAXLEN-2 );	nxsstring tmp = ";";	tmp += next_command;	tmp += "end;";	strcpy( next_command, tmp.c_str() );}/** * @method PrintMessage [void:public] * @param linefeed [bool] if true, places newline character after message * * All output handled here.  Writes string currently stored in message  * (a nxsstring data member) to the output file stream, if open, and also  * to the console via cerr. Places newline after string if linefeed is true. */void BASICCMDLINE::PrintMessage( bool linefeed /* = true */ ){	cerr << message;	if( linefeed )		cerr << endl;	if( logf_open ) {		logf << message;		if( linefeed )			logf << endl;	}}/** * @method PurgeBlocks [void:protected] * * Detaches all blocks, deletes them, creates new blocks, and  * finally adds the new blocks. */void BASICCMDLINE::PurgeBlocks(){	Detach( taxa );	Detach( trees );	Detach( assumptions );	Detach( characters );		delete characters;	delete assumptions;	delete trees;	delete taxa;		taxa = new TaxaBlock();	trees = new TreesBlock(*taxa);	assumptions = new AssumptionsBlock( *taxa );	characters = new CharactersBlock( *taxa, *assumptions );		Add( taxa );	Add( trees );	Add( assumptions );	Add( characters );}/** * @method Read [void:protected] * @param token [NexusToken&] the token used to read from in * @throws XNexus * * This function provides the ability to read everything following * the block name (which is read by the Nexus object) to the end or * endblock statement. Characters are read from the input stream * in. Overrides the pure virtual function in the base class. */void BASICCMDLINE::Read( NexusToken& token ){   isEmpty = false;      // this should be the semicolon after the block name   //	token.GetNextToken();	if( !token.Equals(";") ) {		errormsg = "Expecting ';' after ";      errormsg += id;      errormsg += " block name, but found ";      errormsg += token.GetToken();      errormsg += " instead";		throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );	}	for(;;)	{		token.GetNextToken();		if( token.Abbreviation("ENdblock") ) {			HandleEndblock( token );			break;		}		else if( token.Abbreviation("Help") ) {			HandleHelp( token );		}		else if( token.Abbreviation("Log") ) {			HandleLog( token );		}		else if( token.Abbreviation("EXecute") ) {			HandleExecute( token );		}		else if( token.Abbreviation("Show") ) {			HandleShow( token );		}		else if( token.Abbreviation("Quit") ) {			quit_now = true;						message = "\nBASICCMDLINE says goodbye\n";			PrintMessage();						break;		}		else      {			SkippingCommand( token.GetToken() );         do {            token.GetNextToken();         } while( !token.AtEOF() && !token.Equals(";") );         if( token.AtEOF() ) {				errormsg = "Unexpected end of file encountered";				throw XNexus( errormsg, token.GetFilePosition(), token.GetFileLine(), token.GetFileColumn() );         }		}   }}/** * @method Reset [void:protected] * * Overrides the pure virtual function in the base class. */void BASICCMDLINE::Reset(){   isEmpty = true;	inf_open = false;	quit_now = false;	message = "";	next_command[0] = '\0';}/** * @method Report [virtual void:public] * @param out [ostream&] the output stream to which to write the report * * This function outputs a brief report of the contents of this BASICCMDLINE block. * Overrides the pure virtual function in the base class. */void BASICCMDLINE::Report( ostream& /* out */ ){	message = "";	PrintMessage();	message = id;	message += " block contains...";	PrintMessage();}/** * @method Run [void:public] * * Runs the command line interpreter, allowing BASICCMDLINE to interact with user. * Typically, this is the only function called in main after a BASICCMDLINE object * is created. */void BASICCMDLINE::Run(){	taxa = new TaxaBlock();	trees = new TreesBlock(*taxa);	assumptions = new AssumptionsBlock( *taxa );	characters = new CharactersBlock( *taxa, *assumptions );		Add( taxa );	Add( trees );	Add( assumptions );	Add( characters );	Add( this );		quit_now = false;	while( !quit_now ) 	{		cerr << endl;		cerr << "BASICCMDLINE> ";		cin.getline( next_command, 256 );		PreprocessNextCommand();		HandleNextCommand();	}}/** * @method SkippingBlock [virtual void:public] * @param blockName [nxsstring] the unrecognized block name * * Called when program does not recognize a block name encountered in a  * NEXUS file.  Virtual function that overrides the pure virtual function  * in the base class Nexus. */void BASICCMDLINE::SkippingBlock( nxsstring blockName ){	message = "Skipping unknown block (";	message += blockName;	message += ")";	PrintMessage();}/** * @method SkippingCommand [virtual void:public] * @param commandName [nxsstring] the name of the command being skipped * * This function is called when an unknown command named commandName is * about to be skipped.  This version of the function (which is identical * to the base class version) does nothing (i.e., no warning is issued * that a command was unrecognized).  Modify this virtual function to * provide such warnings to the user (or eliminate it altogether since * the base class version already does what this does). */void BASICCMDLINE::SkippingCommand( nxsstring commandName ){	message = "Skipping unknown command (";	message += commandName;	message += ")";	PrintMessage();}/** * @method SkippingDisabledBlock [virtual void:public] * @param blockName [nxsstring] the name of the block just exited * * Called by the Nexus object when skipping a block named blockName  * that has been disabled. Allows program to notify user of progress  * in parsing the NEXUS file. Virtual function that overrides the  * pure virtual function in the base class Nexus. */void BASICCMDLINE::SkippingDisabledBlock( nxsstring /*blockName*/ ){}/** * @method TaxonLabelToNumber [int:protected] * @param s [nxsstring] the taxon label to be translated to a taxon number * * The code here is identical to the base class version (simply returns 0), * so the code here should either be modified or this derived version * eliminated altogether.  Under what circumstances would you need to * modify the default code, you ask?  This function should be modified * to something meaningful if this derived class needs to construct and * run a SetReader object to read a set involving taxa.  The SetReader * object may need to use this function to look up a taxon label * encountered in the set.  A class that overrides this method should * return the taxon index in the range [1..ntax]; i.e., add one to the * 0-offset index. */int BASICCMDLINE::TaxonLabelToNumber( nxsstring /* s */ ){   return 0;}/** * @method TaxonLabelToNumber [virtual bool:public] * @param mb_message [nxsstring] the question posed to the user * @param mb_title [nxsstring] the title of the message box * * Asks user if "something" is ok, where "something" is expressed * in the title and message displayed.  This is a virtual function * so it can be overridden in a derived class to use a different * (perhaps graphical) means for displaying the message. * Note: mb_message should terminate with a quesiton mark; none * will be provided by this function. */bool BASICCMDLINE::UserSaysOk( nxsstring mb_message, nxsstring mb_title ){	cerr << endl;	cerr << mb_title << endl;	cerr << "  " << mb_message;	cerr << " (y/n) ";		cin.getline( next_command, COMMAND_MAXLEN );	bool yep  = ( next_command[0] == 'y' && next_command[1] == '\0' );	bool nope = ( next_command[0] == 'n' && next_command[1] == '\0' );		while( !yep && !nope )	{		cerr << endl;		cerr << "Must answer by typing either y or n and then pressing the Enter key" << endl;		cerr << endl;		cerr << mb_title << endl;		cerr << "  " << mb_message;		cerr << " (y/n) ";				cin.getline( next_command, COMMAND_MAXLEN );		yep  = ( next_command[0] == 'y' && next_command[1] == '\0' );		nope = ( next_command[0] == 'n' && next_command[1] == '\0' );	}		return yep;}int main(){	BASICCMDLINE basiccmdline;	basiccmdline.Run();	return 0;}